# Оптимизация рабочего графика с помощью **Pyomo**

## **Введение**

В этом проекте разработана модель для оптимизации рабочего графика на основе заданных условий и ограничений. С помощью библиотеки **Pyomo** и Flask разработан веб-интерфейс для создания, решения и визуализации математической модели оптимизации расписания.

## **Основные характеристики**

- **Подбор рабочего**: На основе специализации, разряда рабочих и требований к задаче определяется, какому рабочему будет назначена конкретная задача.
- **Оптимизация времени**: Целью модели является минимизация разницы во времени работы между различными рабочими, а также учёт их предпочтений.
- **Минимизация затрат**: Модель может также минимизировать затраты, с учетом ваших потребностей.
- **Наличие дедлайнов**: Можно задать дедлайны для проектов и указать модели насколько жестко она должна их придерживаться.
- **Недоступность рабочего**: Можно задать период времени, в который рабочий будет недоуступен для задач.
- **Веб-интерфейс**: Легко настроить и запустить веб-интерфейс для работы с моделью.
- **Визуализация результатов**: Мы предоставляем инструменты для визуализации расписания, что позволяет быстро оценить результаты модели.
- **Интерактивные графики**: Наличие интерактивных графиков
- **Воспроизводимость решения**: Решенную модель можно сохранить и загрузить в дальнейшем.

## **Описание функций**

1. `build_model(weight_balance, weight_makespan, weight_costs=1, weight_workers=1, hard_deadline=False)`
    Эта функция строит оптимизационную модель для распределения заданий рабочим.

    **Параметры**:
     - `weight_balance`: Вес для уравновешивания рабочего времени между рабочими.
     - `weight_makespan`: Вес для минимизации общего времени выполнения всех заданий.
     - `weight_costs`: Вес для минимизации общих затрат на всех рабочих.
     - `weight_workers`: Вес для минимизации количества рабочих.
     - `hard_deadline`: Параметр для регулирования жесткости ограничения для дедлайнов проектов. **True** - жесткое ограничение, **False** - мягкое ограничение.
    
    **Возвращает**: экземпляр модели.

2. `solve_model(model, custom_data=False)`
    Эта функция решает модель, построенную с помощью функции `build_model`.

    **Параметры**:
     - `model`: Экземпляр модели, который нужно решить.
     - `custom_data` (необязательный): Если True, будет искать решение используя пользовательские параметры, данные.
  
3. `plot_schedule(model, show=True)`
    Эта функция создает график расписания на основе решенной модели.

    **Параметры**:
     - `model`: Решенный экземпляр модели.
     - `show`: Булевое значение для использования различных интерфейсов, для веб-интерфейса **False** т.к. график будет сохраняться
  
4. `solution_to_file(model)`
    Эта функция сохраняет решение модели в текстовый файл.

    **Параметры**:
     - `model`: Решенный экземпляр модели.

5. `plot_worker_utilization(model)`
    Эта функция создает график, показывающий, как каждый рабочий был задействован в разных заданиях.

    **Параметры**:
     - `model`: Решенный экземпляр модели.

6. `do_n_solutions(n, model)`
    Эта функция решает модель n раз каждый раз исключая предыдущее решение.

    **Параметры**:
     - `n`: Количество раз, которые модель должна быть решена.
     - `model`: Экземпляр модели для решения.

7. `save_model_to_file(model, filename="model.pkl")`
    Сохраняет экземпляр модели в файл с использованием cloudpickle.

    **Параметры**:
     - `model`: Решенный экземпляр модели.
     - `filename`: Название сохраняемого файла

8. `load_model_from_file(filename="model.pkl")`
    Загружает экземпляр модели из файла с использованием cloudpickle.

    **Параметры**:
    - `filename`: Название загружаемого файла

9. `plot_gantt_schedule`

    Эта функция создаёт интерактивный график Ганта для отображения расписания работ на основе решения Pyomo модели.

    **Параметры**:

    - `model`: Модель Pyomo, содержащая информацию о заданиях, рабочих и их расписании.
    - `show`: (По умолчанию True) Если True, то показывает график, в противном случае возвращает данные графика в формате JSON.
    - `mode`: (По умолчанию workers) Определяет, как группировать задания на графике. Если workers, группирует задания по рабочим, если projects по проектам.

    **Возвращает**: 
    Если show установлено в False, возвращает данные графика в формате JSON.

10. `plot_worker_utilization_interactive`

    Эта функция создаёт интерактивный график для отображения степени загрузки рабочих на основе решения Pyomo модели.

    **Параметры**:

    - `model`: Модель Pyomo, содержащая информацию о заданиях, рабочих и их загрузке.
    - `show`: (По умолчанию True) Если True, то показывает график, в противном случае возвращает данные графика в формате JSON.

    **Возвращает**: Если show установлено в False, возвращает данные графика в формате JSON.
## **Описание данных:**

Для корректной работы модели необходимы следующие данные:

1. **jobs_data**: Это словарь, где ключи представляют идентификаторы задач, а значения - кортежи, содержащие информацию о задачах. Каждый кортеж содержит:
 - Требуемую специализацию для выполнения задачи.
 - Продолжительность задачи.
 - Список предшествующих задач.
 - Требуемая минимальная квалификация для выполнения.
2. **workers_data**: Словарь, где ключи представляют идентификаторы рабочих, а значения - их специализацию, разряд, цена за минуту рабочего времени и период недоступности, если есть.
3.  **project_data**: Словарь, где ключи представляют идентификаторы проектов, а значения - список задач проекта и его дедлайн.
4. **task_to_project**: Словарь, который связывает каждую задачу с проектом, к которому она относится. Генерируется из **project_data**

## **Инструкция по запуску проекта**

### **Предварительные требования:**

1. **Python**: Убедитесь, что у вас установлен Python (рекомендуется версия 3.x).

2. **pip**: Если у вас еще не установлен pip, установите его. Это пакетный менеджер для Python, который позволяет устанавливать дополнительные библиотеки.

### **Установка зависимостей:**

1. **Зависимости из файла `requirements.txt`:**
    Откройте терминал или командную строку и перейдите в директорию, где находится ваш проект. Затем выполните следующую команду:
     - `pip install -r requirements.txt`

### **Запуск:**

1. **Запуск основного интерфейса:**
    После установки всех зависимостей, вы можете запустить главный интерфейс, используя следующую команду:
     - `python UI.py`
2. **Запуск веб-интерфейса**:
    Перейдите в вашем веб-браузере по адресу: `http://localhost:5000/` после запуска `webui.py`.
  

### **Дополнительно:** 
 - Функции, которые используются в `UI.py`, импортируются из файла `jssp.py`.
 - Для решения задачи используются два дополнительных файла: `hghspy.py` (highspy) и `cylp.py` (CyClpSimplex). Эти файлы используют mps модель, созданную в `jssp.py`, и выводят решение.
 - CSS для оформления веб-интерфейса находится в файле `styles.css`.

